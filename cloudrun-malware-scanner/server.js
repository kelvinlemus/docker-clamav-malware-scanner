/*
* Copyright 2021 Google LLC

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

*     https://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

const clamd = require('clamdjs');
const express = require('express');
const {Storage} = require('@google-cloud/storage');
const {ApiError} = require('@google-cloud/common');
const {logger} = require('./logger.js');
const pkgJson = require('./package.json');

const PORT = process.env.PORT || 8080;
const CLAMD_HOST = '127.0.0.1';
const CLAMD_PORT = 3310;
const MAX_FILE_SIZE = 5000000000; // 5GiB
const LOG_PREFIX = '[MALWARE_SCANNER]'
const FLAG_SUFFIX = '_unscanned'

// Create Clients.
const app = express();
app.use(express.json());
const scanner = clamd.createScanner(CLAMD_HOST, CLAMD_PORT);
const storage = new Storage();

/**
 * Route that is invoked by Cloud Run when a malware scan is requested
 * for a document uploaded to GCS.
 *
 * @param {!Request} req The request payload
 * @param {!Response} res The HTTP response object
 */
app.post('/', async (req, res) => {
  // Sanity check required values.
  if (!req.body || req.body.kind !== 'storage#object') {
    handleErrorResponse(res, 200, `${req.body} is not a GCS Storage Object`);
    return;
  }

  const file = req.body;
  try {
    if (!file.name) {
      handleErrorResponse(res, 200, `file name not specified in ${file}`);
      return;
    }
    if (!file.name.includes(FLAG_SUFFIX)) {
      res.status(204).send()
      return;
    }
    if (!file.bucket) {
      handleErrorResponse(res, 200, `bucket name not specified in ${file}`);
      return;
    }
    if (file.size > MAX_FILE_SIZE) {
      handleErrorResponse(
          res, 200,
          `file gs://${file.bucket}/${file.name} too large for scanning at ${
            file.size} bytes`);
      return;
    }

    const bucket = storage.bucket(file.bucket);
    const flagFile = bucket.file(file.name);
    const gcsFileName = file.name.replace(FLAG_SUFFIX, '')
    const gcsFile = bucket.file(gcsFileName);

    // File.exists() returns a FileExistsResponse, which is a list with a
    // single value.
    if (! (await gcsFile.exists())[0]) {
      handleErrorResponse(res, 200,
          `GCS File: gs://${file.bucket}/${gcsFileName} does not exist`);
      return;
    }

    if (! (await flagFile.exists())[0]) {
      handleErrorResponse(res, 200,
          `GCS Flag File: gs://${file.bucket}/${file.name} does not exist`);
      return;
    }

    await flagFile.delete()

    const clamdVersion = await getClamVersion();
    logger.info(`${LOG_PREFIX} Scan request for gs://${file.bucket}/${file.name}, (${
      file.size} bytes) scanning with clam ${clamdVersion}`);
    const startTime = Date.now();
    const readStream = await gcsFile.createReadStream();
    let result;
    try {
      result = await scanner.scanStream(readStream);
    } finally {
      // Ensure stream is destroyed in all situations to prevent any
      // resource leaks.
      readStream.destroy();
    }
    const scanDuration = Date.now() - startTime;

    if (clamd.isCleanReply(result)) {
      logger.info(`${LOG_PREFIX} Scan status for gs://${file.bucket}/${file.name}: CLEAN (${
        file.size} bytes in ${scanDuration} ms)`);

      const gcsFileMetadata = await gcsFile.getMetadata();
      let newMetadata = gcsFileMetadata[0].metadata || {};
      newMetadata['scanning'] = 'clean';

      await gcsFile.setMetadata({ metadata: newMetadata })

      // Respond to API client.
      res.json({status: 'clean', clam_version: clamdVersion});
    } else {
      logger.warn(`${LOG_PREFIX} Scan status for gs://${file.bucket}/${
        file.name}: INFECTED ${result} (${
        file.size} bytes in ${scanDuration} ms)`);

      const gcsFileMetadata = await gcsFile.getMetadata();
      let newMetadata = gcsFileMetadata[0].metadata || {};
      newMetadata['scanning'] = 'infected';

      await gcsFile.delete();
      const newGcsFile = bucket.file(gcsFileName);
      await newGcsFile.save('')
      await gcsFile.setMetadata({
        metadata: newMetadata
      })

      // Respond to API client.
      res.json({
        message: result,
        status: 'infected',
        result: result,
        clam_version: clamdVersion,
      });
    }
  } catch (e) {
    logger.error(
        {err: e},
        `${LOG_PREFIX} Exception when processing gs://${file.bucket}/${file.name}: %s`,
        e.message);

    // A 500 will cause Pubsub/EventArc to retry the event.
    let statusCode=500;

    if ((e instanceof ApiError) && [403, 404].includes(e.code) ) {
      // Permission denied/file not found can be raised by the stream reading
      // and by the object move. They cannot be retried, so respond
      // with success, but log the error.
      statusCode=200;
    }

    handleErrorResponse(res, statusCode,
        `gs://${file.bucket}/${file.name}: ${e.message}`);
  }
});

/**
 * Trivial handler for get requests which returns the clam version.
 *
 * Use:
 * curl -D - -H "Authorization: Bearer $(gcloud auth print-identity-token)"  \
     CLOUD_RUN_APP_URL
 * @param {!Request} req
 * @param {!Response} res
 */
app.get('/', async (req, res) => {
  res.status(200)
      .type('text/plain')
      .send(
          `${pkgJson.name} version ${pkgJson.version}
Using Clam AV version: ${await getClamVersion()}      

${pkgJson.description}
(Responds to POST requests containing a GCS object only)

`);
});

/**
 * Respond with an error and log the message
 *
 * Note: any non-successful status codes will cause the caller (PubSub/Eventarc)
 * to retry sending the event, so use 200 for non-retryable errors.
 *
 * @param {Object} res response object
 * @param {number} statusCode
 * @param {string} errorMessage
 */
function handleErrorResponse(res, statusCode, errorMessage) {
  logger.error(`${LOG_PREFIX} Error processing request: ${errorMessage}`);
  res.status(statusCode).json({message: errorMessage, status: 'error'});
}

/**
 * Wrapper to get a clean string with the version of CLAM.
 * @return {Promise<string>}
 */
async function getClamVersion() {
  return (await clamd.version(CLAMD_HOST, CLAMD_PORT)).replaceAll('\x00', '');
}

/**
 * Start the app.
 */
async function run() {
  app.listen(PORT, () => {
    logger.info(
        `${pkgJson.name} version ${pkgJson.version} started on port ${PORT}`);
  });
}

// Start the service, exiting on error.
run().catch((e) => {
  logger.fatal(e);
  logger.fatal('Exiting');
  process.exit(1);
});
